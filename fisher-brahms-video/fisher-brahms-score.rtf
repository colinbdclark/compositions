{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 // TODO: Smooth mix between loop and playback\cf0 \
\cf2 //              Smooth transition between speeds--ramp up/down\cf0 \
\cf2 // 	    Variation in speed and pitch for looper.\cf0 \
\cf2 //              Increase likelihood of regular-speed playback (possibly vary this likelihood based on volume)\
//              Randomize sampling length and speed each time around\cf0 \
\
(\
	\cf3 var\cf0  makeGroupedSynths, makeOutputController,\
	       trackSynthState, flipState,\
	       makePeriodicSetter, makeGaussianRandomizer,\
	       riversBus, rivers, loopersBus, loopers, leftOutput, rightOutput,\
	       leftSynths, rightSynths,\
	       volTriggerStates,\
	       volumeRoutine, speedRoutine, sustainLevelRoutine, \
	       dramaResponder;\
	\
	makeGroupedSynths = \{\
		\cf3 arg\cf0  defName, buffers, outputBusNum;\
		\
		\cf3 var\cf0  group = \cf3 Group\cf0 .new,\
		       synths = \cf3 List\cf0 .new;\
		\
		buffers.do(\{\
			\cf3 arg\cf0  buffer, idx;\
			\cf3 var\cf0  synth = \cf3 Synth\cf0 .new(\
				defName: defName,\
				args: [\cf4 "bufnum"\cf0 , buffer.bufnum, \cf4 "outputBusNum"\cf0 , outputBusNum + idx],\
				target: group,\
				addAction: \cf5 \\addToTail\cf0 \
			);\
			synths.add(synth);\
		\});\
		\
		synths;\
	\};\
	\
	makeOutputController = \{\
		\cf3 arg\cf0  riverBusNum, looperBusNum, channelOffset;\
		\
		\cf3 Synth\cf0 .new(\
			defName: \cf4 "OutputController"\cf0 ,\
			args: [\
				\cf4 "riverBusNum"\cf0 , riverBusNum  + channelOffset,\
				\cf4 "looperBusNum"\cf0 , looperBusNum  + channelOffset,\
				\cf4 "outputBusNum"\cf0 , channelOffset\
			],\
			addAction: \cf5 \\addToTail\cf0 \
		);		\
	\};\
	\
	trackSynthState = \{\
		\cf3 arg\cf0  synths, stateParam;\
		\cf3 var\cf0  states = \cf3 IdentityDictionary\cf0 .new;\
		\
		synths.do(\{\
			\cf3 arg\cf0  synth;\
			synth.get(stateParam, \{\
				\cf3 arg\cf0  val;\
				states.put(synth, val);\
			\});\
		\});\
		\
		states;\
	\};\
	\
	flipState = \{\
		\cf3 arg\cf0  states, synth;\
		\cf3 var\cf0  state = states.at(synth);\
		\
		if (state == 1.0, \{\
			state = 0.0;\
		\}, \{\
			state =1.0;\
		\});\
		states.put(synth, state);\
		\
		state;\
	\};\
	\
	makePeriodicSetter = \{\
		\cf3 arg\cf0  synths, paramName, waitRandomizer, paramCalculator, runFor  = \cf3 inf\cf0 ;\
		\
		\cf3 var\cf0  setter = \cf3 Routine\cf0 .new(\{\
			runFor.do(\{\
				\cf3 var\cf0  waitDur = waitRandomizer.value(),\
				       synth, paramValue;\
				 \
				 waitDur.wait;\
				 synth = synths.choose;\
				 paramValue = paramCalculator.value(synth, paramName, waitDur);\
				 synth.set(paramName, paramValue);\
				 \
				(\cf4 "After"\cf0  + waitDur + \cf4 "seconds, set"\cf0  + paramName + \
				 \cf4 "on syth"\cf0  + synth.nodeID + \cf4 "to"\cf0  + paramValue).postln; \
			\});\
		\}); \
		setter.play(\cf3 SystemClock\cf0 );\
		setter;\
	\};\
	\
	makeGaussianRandomizer = \{\
		\cf3 arg\cf0  centre, deviation;\
		\
		\{\
			centre.gaussian(deviation);\
		\}\
	\};\
					\
					\
	\cf2 // Live state.\cf0 \
	riversBus = \cf3 Bus\cf0 .audio(s, 2);\
	rivers = makeGroupedSynths.value(\cf4 "River"\cf0 , [~left, ~right],  riversBus.index);\
	loopersBus = \cf3 Bus\cf0 .audio(s, 2);\
	loopers = makeGroupedSynths.value(\cf4 "Looper"\cf0 , [~left, ~right], loopersBus.index);\
	leftOutput = makeOutputController.value(riversBus.index, loopersBus.index, 0);\
	rightOutput = makeOutputController.value(riversBus.index, loopersBus.index, 1);\
	\
	leftSynths = \cf3 Dictionary\cf0 .new;\
	leftSynths.put(\cf4 "river"\cf0 , rivers[0]);\
	leftSynths.put(\cf4 "looper"\cf0 , loopers[0]);\
	leftSynths.put(\cf4 "output"\cf0 , leftOutput);\
	\
	rightSynths = \cf3 Dictionary\cf0 .new;\
	rightSynths.put(\cf4 "river"\cf0 , rivers[1]);\
	rightSynths.put(\cf4 "looper"\cf0 , loopers[1]);\
	rightSynths.put(\cf4 "output"\cf0 , rightOutput);\
	\
	\cf2 // Periodically trigger both synths' volume envelopes randomly.\cf0 \
	volTriggerStates = trackSynthState.value(rivers);\
	volumeRoutine = makePeriodicSetter.value(rivers, \cf4 "volTrigger"\cf0 , makeGaussianRandomizer.value(4.0, 3.0), \{\
		\cf3 arg\cf0  synth;\
			\
		flipState.value(volTriggerStates, synth);\
	\});\
	\
	\cf2 // Periodically change the playback speed.\cf0 \
	speedRoutine = makePeriodicSetter.value(rivers, \cf4 "speed"\cf0 , makeGaussianRandomizer.value(10.0, 3.0), \{\
		[0.25, 0.50, 0.50, 1.0, 1.0, 1.0].choose;\
	\});\
	\
	\cf2 // And the sustain level.\cf0 \
	sustainLevelRoutine = makePeriodicSetter.value(rivers, \cf4 "volLevel"\cf0 , makeGaussianRandomizer.value(4.0, 3.0), \{\
		1.0.rand();\
	\});\
	\
	\cf2 // Reports volume increases to the output controller.\cf0 \
	dramaResponder = \cf3 OSCresponderNode\cf0 (s.addr, \cf4 "/tr"\cf0 , \{\
		\cf3 arg\cf0  time, responder, msg;\
		\
		\cf3 var\cf0  nodeId = msg[1],\
		       state = msg[2],\
		       frameIdx = msg[3],\
		       channelSynths,\
		       looper,\
		       output;\
		       \
		 (\cf4 "Recieved message from"\cf0  + nodeId + \cf4 ":"\cf0  + \cf4 "drama is"\cf0  + state + \cf4 ", frameIdx is"\cf0  + frameIdx).postln;\
		 \
		 if (nodeId == leftSynths.at(\cf4 "river"\cf0 ).nodeID, \{\
			 channelSynths = leftSynths;\
		 \}, \{\
			 channelSynths = rightSynths;\
		 \});\
		 \
		 looper = channelSynths.at(\cf4 "looper"\cf0 );\
		 output = channelSynths.at(\cf4 "output"\cf0 );\
		 looper.set(\cf4 "start"\cf0 , frameIdx);\
		 looper.set(\cf4 "end"\cf0 , frameIdx + 22050); \cf2 // TODO: Dynamically set the loop length.\cf0 \
		 looper.set(\cf4 "speed"\cf0 , [0.25, 0.25, 0.5, 0.5, 0.5, 1.0].choose);\
		 looper.set(\cf4 "trig"\cf0 , 1.0);\
		 output.set(\cf4 "isDramatic"\cf0 , state);\
	\});\
	dramaResponder.add;\
)}